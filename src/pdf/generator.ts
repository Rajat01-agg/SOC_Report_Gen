import PDFDocument from 'pdfkit';

export interface SecurityFinding {
  id?: string;
  title: string;
  severity: 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL';
  description: string;
  recommendation: string;
  timestamp: string;
  source: string;
}

export interface ReportData {
  executionId: string;
  findings: SecurityFinding[];
  metadata: {
    generatedAt: Date;
    totalFindings: number;
    criticalCount: number;
    highCount: number;
    mediumCount: number;
    lowCount: number;
  };
}

interface SeverityInfo {
  label: string;
  count: number;
  color: string;
  bgColor: string;
}

export class PDFGenerator {
  private readonly colors = {
    primary: '#1e3a8a',
    secondary: '#3b82f6',
    critical: '#dc2626',
    high: '#f97316',
    medium: '#eab308',
    low: '#22c55e',
    text: '#1f2937',
    textLight: '#6b7280',
    border: '#e5e7eb',
    background: '#f9fafb',
    white: '#ffffff',
    teal: '#0d9488',
  };

  private pageCount = 0;
  private isFirstContentPage = true;

  async generateReport(reportData: ReportData): Promise<Buffer> {
    return new Promise((resolve, reject) => {
      try {
        this.pageCount = 0;
        this.isFirstContentPage = true;

        const doc = new PDFDocument({
          margin: 60,
          size: 'A4',
          info: {
            Title: `SOC Security Report - ${reportData.executionId}`,
            Author: 'SOC Report Generator v2.0',
            Subject: 'Security Assessment Report',
            Keywords: 'security, soc, assessment, findings',
            CreationDate: new Date(),
          },
          autoFirstPage: false,
        });

        const buffers: Buffer[] = [];

        doc.on('data', (chunk) => buffers.push(chunk));
        doc.on('end', () => resolve(Buffer.concat(buffers)));
        doc.on('error', reject);

        // Add cover page
        this.addNewPage(doc, false);
        this.addCoverPage(doc, reportData);

        // Add executive summary
        this.addNewPage(doc, false);
        this.addExecutiveSummary(doc, reportData);

        // Add detailed findings
        this.addNewPage(doc, true);
        this.addDetailedFindings(doc, reportData);

        doc.end();
      } catch (error) {
        reject(error);
      }
    });
  }

  private addNewPage(doc: typeof PDFDocument.prototype, addHeader: boolean = true): void {
    doc.addPage();
    this.pageCount++;

    // Add header on continuation pages (not cover, not executive summary)
    if (addHeader && this.pageCount > 2) {
      this.addPageHeader(doc);
    }
  }

  private addPageHeader(doc: typeof PDFDocument.prototype): void {
    const savedY = doc.y;

    doc.fontSize(8)
      .font('Helvetica')
      .fillColor(this.colors.textLight)
      .text(
        'Generated by SOC Report Generator - CONFIDENTIAL',
        60,
        30,
        { width: doc.page.width - 120, align: 'center', lineBreak: false }
      );

    doc.moveTo(60, 45)
      .lineTo(doc.page.width - 60, 45)
      .lineWidth(0.5)
      .strokeColor(this.colors.border)
      .stroke();

    doc.y = 60;
  }

  private addCoverPage(doc: typeof PDFDocument.prototype, reportData: ReportData): void {
    const pageWidth = doc.page.width;
    const pageHeight = doc.page.height;

    // Blue header
    doc.rect(0, 0, pageWidth, 200).fill(this.colors.primary);

    doc.fontSize(32)
      .font('Helvetica-Bold')
      .fillColor(this.colors.white)
      .text('SECURITY OPERATIONS CENTER', 60, 60, { align: 'center', width: pageWidth - 120 });

    doc.fontSize(22)
      .fillColor('#93c5fd')
      .text('Security Assessment Report', 60, 150, { align: 'center', width: pageWidth - 120 });

    // Report Details section
    doc.fontSize(18)
      .font('Helvetica-Bold')
      .fillColor(this.colors.primary)
      .text('Report Details', 60, 250);

    const detailsY = 290;
    const lineHeight = 28;

    const details = [
      { label: 'Report ID:', value: reportData.executionId },
      {
        label: 'Generated:', value: reportData.metadata.generatedAt.toLocaleDateString('en-US', {
          year: 'numeric', month: 'long', day: 'numeric'
        })
      },
      { label: 'Time:', value: reportData.metadata.generatedAt.toLocaleTimeString('en-US') },
      { label: 'Total Findings:', value: reportData.metadata.totalFindings.toString() },
      { label: 'Status:', value: 'Completed' },
    ];

    details.forEach((detail, i) => {
      const y = detailsY + (i * lineHeight);
      doc.fontSize(11)
        .font('Helvetica-Bold')
        .fillColor(this.colors.textLight)
        .text(detail.label, 80, y, { continued: true })
        .font('Helvetica')
        .fillColor(this.colors.text)
        .text(detail.value);
    });

    // Findings Summary box
    const summaryBoxY = 470;
    const boxWidth = pageWidth - 120;
    const boxHeight = 140;

    doc.roundedRect(60, summaryBoxY, boxWidth, boxHeight, 8)
      .fillAndStroke(this.colors.background, this.colors.border);

    doc.fontSize(16)
      .font('Helvetica-Bold')
      .fillColor(this.colors.primary)
      .text('Findings Summary', 80, summaryBoxY + 20);

    const severities: SeverityInfo[] = [
      { label: 'Critical', count: reportData.metadata.criticalCount, color: this.colors.critical, bgColor: '#fee2e2' },
      { label: 'High', count: reportData.metadata.highCount, color: this.colors.high, bgColor: '#ffedd5' },
      { label: 'Medium', count: reportData.metadata.mediumCount, color: this.colors.medium, bgColor: '#fef9c3' },
      { label: 'Low', count: reportData.metadata.lowCount, color: this.colors.low, bgColor: '#dcfce7' },
    ];

    const badgeStartY = summaryBoxY + 55;
    const badgeSpacing = (boxWidth - 40) / 4;

    severities.forEach((sev, i) => {
      const badgeX = 70 + (i * badgeSpacing);
      const badgeWidth = badgeSpacing - 10;

      doc.roundedRect(badgeX, badgeStartY, badgeWidth, 60, 6)
        .fillAndStroke(sev.bgColor, sev.color);

      doc.fontSize(28)
        .font('Helvetica-Bold')
        .fillColor(sev.color)
        .text(sev.count.toString(), badgeX, badgeStartY + 10, { width: badgeWidth, align: 'center' });

      doc.fontSize(10)
        .font('Helvetica')
        .fillColor(this.colors.textLight)
        .text(sev.label, badgeX, badgeStartY + 42, { width: badgeWidth, align: 'center' });
    });

    // Confidential notice
    doc.fontSize(9)
      .fillColor(this.colors.textLight)
      .text('CONFIDENTIAL - FOR AUTHORIZED PERSONNEL ONLY', 60, pageHeight - 80, {
        align: 'center',
        width: pageWidth - 120,
      });

    // Separator line at bottom
    doc.moveTo(60, pageHeight - 60)
      .lineTo(pageWidth - 60, pageHeight - 60)
      .lineWidth(0.5)
      .strokeColor(this.colors.border)
      .stroke();
  }

  private addExecutiveSummary(doc: typeof PDFDocument.prototype, reportData: ReportData): void {
    // Title
    doc.fontSize(24)
      .font('Helvetica-Bold')
      .fillColor(this.colors.primary)
      .text('Executive Summary', 60, 60);

    doc.moveTo(60, 95)
      .lineTo(doc.page.width - 60, 95)
      .lineWidth(2)
      .strokeColor(this.colors.secondary)
      .stroke();

    // Description
    doc.fontSize(11)
      .font('Helvetica')
      .fillColor(this.colors.text)
      .text(
        'This security assessment report provides a comprehensive analysis of security findings identified during the monitoring period. Each finding has been categorized by severity and includes detailed recommendations for remediation.',
        60,
        115,
        { width: doc.page.width - 120, lineGap: 4, align: 'justify' }
      );

    doc.moveDown(2);

    // Risk Distribution Analysis
    doc.fontSize(16)
      .font('Helvetica-Bold')
      .fillColor(this.colors.primary)
      .text('Risk Distribution Analysis', 60, doc.y);

    doc.moveDown(1);

    const severities = [
      { label: 'Critical', count: reportData.metadata.criticalCount, color: this.colors.critical },
      { label: 'High', count: reportData.metadata.highCount, color: this.colors.high },
      { label: 'Medium', count: reportData.metadata.mediumCount, color: this.colors.medium },
      { label: 'Low', count: reportData.metadata.lowCount, color: this.colors.low },
    ];

    const maxCount = Math.max(...severities.map(s => s.count), 1);
    const chartWidth = 350;
    const chartStartX = 120;

    severities.forEach((sev) => {
      const y = doc.y;
      const barWidth = Math.max((sev.count / maxCount) * chartWidth, 5);

      doc.rect(chartStartX, y, barWidth, 22)
        .fill(sev.color);

      doc.fontSize(11)
        .font('Helvetica-Bold')
        .fillColor(this.colors.text)
        .text(sev.label, 60, y + 5);

      doc.font('Helvetica')
        .text(`${sev.count} finding${sev.count !== 1 ? 's' : ''}`, chartStartX + barWidth + 10, y + 5);

      doc.moveDown(1.2);
    });

    doc.moveDown(1.5);

    // Recommended Actions
    doc.fontSize(16)
      .font('Helvetica-Bold')
      .fillColor(this.colors.primary)
      .text('Recommended Actions', 60, doc.y);

    doc.moveDown(0.8);

    const recommendations = [
      'Address all critical findings within 24 hours',
      'Review and remediate high severity findings within 48 hours',
      'Implement fixes for medium severity findings within 1 week',
      'Schedule low severity findings for next maintenance window',
      'Update security policies based on identified patterns',
      'Enhance monitoring for detected threat vectors',
    ];

    recommendations.forEach((rec) => {
      doc.fontSize(10)
        .font('Helvetica')
        .fillColor(this.colors.text)
        .text('• ' + rec, 70, doc.y, { width: doc.page.width - 140, lineGap: 2 });

      doc.moveDown(0.5);
    });
  }

  private addDetailedFindings(doc: typeof PDFDocument.prototype, reportData: ReportData): void {
    // Title with underline
    doc.fontSize(24)
      .font('Helvetica-Bold')
      .fillColor(this.colors.primary)
      .text('Detailed Security Findings', 60, doc.y);

    // Underline
    const titleEndY = doc.y;
    doc.moveTo(60, titleEndY + 5)
      .lineTo(280, titleEndY + 5)
      .lineWidth(1)
      .strokeColor(this.colors.primary)
      .stroke();

    doc.moveDown(1.5);

    reportData.findings.forEach((finding, index) => {
      // Check if we need a new page
      if (doc.y + this.estimateFindingHeight(finding) > doc.page.height - 80) {
        this.addNewPage(doc, true);
      }

      // Finding title
      doc.fontSize(14)
        .font('Helvetica-Bold')
        .fillColor(this.colors.text)
        .text(`${index + 1}. ${finding.title}`, 60, doc.y);

      // Severity badge below title
      const severityColor = this.getSeverityColor(finding.severity);
      doc.fontSize(10)
        .font('Helvetica-Bold')
        .fillColor(severityColor)
        .text(`[${finding.severity}]`, 60, doc.y);

      // Source and Time
      doc.fontSize(9)
        .font('Helvetica')
        .fillColor(this.colors.text)
        .text(
          `• Source: ${finding.source} • Time: ${new Date(finding.timestamp).toLocaleString('en-GB', {
            day: 'numeric',
            month: 'numeric',
            year: 'numeric',
            hour: 'numeric',
            minute: '2-digit',
            hour12: true
          }).toLowerCase()}`,
          60, doc.y
        );

      doc.moveDown(0.8);

      // Description
      doc.fontSize(10)
        .font('Helvetica-Bold')
        .fillColor(this.colors.text)
        .text('Description:', 80, doc.y);

      doc.fontSize(10)
        .font('Helvetica')
        .fillColor(this.colors.text)
        .text(finding.description, 100, doc.y, {
          width: doc.page.width - 160,
          lineGap: 2,
        });

      doc.moveDown(0.8);

      // Recommendation
      doc.fontSize(10)
        .font('Helvetica-Bold')
        .fillColor(this.colors.text)
        .text('Recommendation:', 80, doc.y);

      // Parse recommendations and display as numbered list
      const recText = finding.recommendation;
      const recItems = this.parseRecommendations(recText);

      recItems.forEach((item, i) => {
        doc.fontSize(10)
          .font('Helvetica')
          .fillColor(this.colors.teal)
          .text(`${i + 1}. ${item}`, 100, doc.y, {
            width: doc.page.width - 160,
            lineGap: 1,
          });
      });

      doc.moveDown(2);
    });
  }

  private parseRecommendations(text: string): string[] {
    // Try to split by common patterns
    // If it contains numbered items like "1." or "2."
    const numberedPattern = /\d+\.\s+/;
    if (numberedPattern.test(text)) {
      return text.split(/\d+\.\s+/).filter(s => s.trim().length > 0);
    }

    // If it contains bullet points or semicolons
    if (text.includes(';')) {
      return text.split(';').filter(s => s.trim().length > 0).map(s => s.trim());
    }

    // If it contains commas and is long
    if (text.includes(',') && text.length > 100) {
      return text.split(',').filter(s => s.trim().length > 0).map(s => s.trim());
    }

    // Otherwise return as single item
    return [text];
  }

  private estimateFindingHeight(finding: SecurityFinding): number {
    const titleHeight = 25;
    const severityHeight = 20;
    const metadataHeight = 20;
    const descriptionLines = Math.ceil(finding.description.length / 80);
    const descriptionHeight = descriptionLines * 14 + 30;
    const recItems = this.parseRecommendations(finding.recommendation);
    const recommendationHeight = recItems.length * 16 + 30;
    const padding = 40;

    return titleHeight + severityHeight + metadataHeight + descriptionHeight + recommendationHeight + padding;
  }

  private getSeverityColor(severity: string): string {
    switch (severity.toUpperCase()) {
      case 'CRITICAL': return this.colors.critical;
      case 'HIGH': return this.colors.high;
      case 'MEDIUM': return this.colors.medium;
      case 'LOW': return this.colors.low;
      default: return this.colors.textLight;
    }
  }

  analyzeFindings(findings: SecurityFinding[]): {
    totalFindings: number;
    criticalCount: number;
    highCount: number;
    mediumCount: number;
    lowCount: number;
  } {
    const counts = {
      totalFindings: findings.length,
      criticalCount: 0,
      highCount: 0,
      mediumCount: 0,
      lowCount: 0,
    };

    findings.forEach((finding) => {
      const severity = (finding.severity || 'MEDIUM').toUpperCase();
      switch (severity) {
        case 'CRITICAL':
          counts.criticalCount++;
          break;
        case 'HIGH':
          counts.highCount++;
          break;
        case 'MEDIUM':
          counts.mediumCount++;
          break;
        case 'LOW':
          counts.lowCount++;
          break;
      }
    });

    return counts;
  }
}

export default PDFGenerator;